[{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1","title":"About The Fee Office","content":"The Fee Office is a demo application based on the es-emergency-call Need help with finding aggregates and bounded contexts in our domain by @enumag.It is a prototype implementation showing the result of a model exploration and knowledge crunching process."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-1","title":"What's insight?","content":"An online book summarizes and documents the process of crunching knowledge and how we used the knowledge to identify bounded contexts and aggregates as well as a good architecture for each bounded context and the system as a large.Note: The book and the prototype are both work in progress."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-2","title":"Architecture","content":"The system is split into 5 contexts and each context is implemented as an autonomous module within a monolithic application. Think of those modules as (mico)services deployed together. That said, we combine autonomy of bounded contexts (implemented as modules) with the ease of deploying and operating a monolithic system. Because we keep modules separated (even on database level) we are able to split the system later and scale up individual modules if needed. We also keep the model of each context decoupled from the other models - a very important property of a system that is constantly improved and reshaped."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-1","title":"Infrastructure","content":" Docker &amp; Docker Compose Nginx PostgreSQL "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-2","title":"Programming Language","content":" PHP 7.x "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-3","title":"API Gateway &amp; Module System","content":" zend\/expressive "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-4","title":"Dependency Mgmt","content":" composer "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-5","title":"Event Sourcing","content":" Event Machine "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/about.html#1-1-3-6","title":"State Persistence","content":" PostgreSQL Document Store Continue with setting up the demo application using Docker. You'll find instructions on the next page."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/installation.html#1-2","title":"Installation","content":"Docker is the only supported way to run the demo application. The commands shown here work on a Linux system with Git, Docker and Docker Compose installed.git clone https:\/\/github.com\/proophsoftware\/fee-office.git cd fee-office docker run --rm -it -v $(pwd):\/app prooph\/composer:7.2 install sudo chown $(id -u -n):$(id -g -n) . -R docker-compose up -d "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/installation.html#1-2-1","title":"Troubleshooting","content":"With the command docker-compose ps you can list the running containers. Make sure that all required ports are available on your machine. If not you can modify port mapping in the docker-compose.yml."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/installation.html#1-2-1-1","title":"Have you tried turning it off and on again?","content":"If something does not work as expected try to restart the containers first:$ docker-compose down $ docker-compose up -d "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/installation.html#1-2-1-2","title":"Projection reset","content":"TODOTo better understand the system read about \"autonomous modules\" on the next page."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/module_system.html#1-3","title":"Autonomous Modules","content":"The Fee Office is split into 5 bounded contexts. Each context is represented as a software module in our system. But we don't use a monolithic MVC module approach like you know from ZendFramework 2 modules or Symfony bundles. Instead we use the lightweight module system provided by Zend Expressive.The technique used in the demo is not bound to zend expressive. We've picked it because expressive uses PSR standards and has a module system that works the way we need it. Anyway, you can achieve the same project structure using any existing PHP framework and composer. We recommend asking the respective framework community if you're not sure how to do it with your framework of choice."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/module_system.html#1-3-1","title":"The Rules","content":"Each module should be completely independent of any other module even if all modules are deployed on the same server.To achieve module autonomy we use a special set up. It is a combination of Expressive modules which are also composer packages. More on that in a minute. Furthermore, an application layer acts as the glue layer to coordinate communication between users\/clients and modules as well as between the modules \"talking\" to each other. Each module has its own URL root path, f.e. the RealtyRegistration module uses the path \/realty\/.... Each module has its own composer.json and only uses dependencies defined in that composer.json OR provided by the application layer. Each module has at least a dedicated database schema assigned to it, if not its own database(s). No module is allowed to use a class or function defined in another module. The following diagram illustrates the architecture:If we later want to deploy one or more modules separated from the others (turn a module into a microservice), we can \"easily\" do that by deploying the module together with the application layer and globally defined dependencies provided by the application layer."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/module_system.html#1-3-2","title":"Application Layer","content":"We've installed the zend\/expressive-skeleton with Fastroute, zend\/servicemanager, no template engine and the Whoops error handler. We've also enabled the module system of expressive.The application layer takes over a few tasks: It uses the zend-component-installer to install our modules. The installer is a composer plugin registered in the root composer.json of the application layer. It merges module config and provides env vars via app.env It performs routing of http requests using Fastroute It provides an error handler (Whoops) and could also include authentication and authorization (not included in the demo) It provides client libraries available for all modules, f.e. a logger, a service bus + basic message classes, etc. The application layer uses the App namespace."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/module_system.html#1-3-3","title":"Modules","content":"A module has its own namespace. For example the RealtyRegistration module uses the namespace FeeOffice\\RealtyRegistration. The namespace maps to the path src\/RealtyRegistration\/src.A module also has its own composer.json where all dependencies of the module should be defined.A module is not allowed to use dependencies that are not defined in its own composer.json. The only exception are global dependencies (client libraries) provided or imported by the application layer. At the moment this is a convention and needs to be ensured by code reviews. In the future we might add a tool that performs automated code scans to ensure that rule.In the application's root composer.json each module is included as local package:\"repositories\": [ { \"type\": \"path\", \"url\": \"src\/RealtyRegistration\" } ], \"require\": { \"php\": \"^7.1\", \"feeoffice\/realty-registration\": \"*\", Example of importing the RealtyRegistration module as package in the root composer.jsonWe use composer to manage module dependencies and add the module namespace to the autoloader. That said, each module can require its own dependencies but as long as modules are deployed together, composer makes sure that different dependency versions don't conflict with each other.Defining module dependencies per module makes it much easier to deploy them independently later.Each module has a config provider and the zend-component-installer composer plugin automatically adds each config provider to the expressive config manager of the application layer. This way, modules provide their own routing and middleware pipe configuration as well as module specific DI definitions.Clean and nice separation of concern which makes it very easy to build a true modularized application with the option to turn it into microservices if needed."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/module_system.html#1-3-4","title":"Benefits","content":"When using a module approach for the first time you'll probably think it is overengineerd because you need some extra effort to access data owned by another module. I'll highlight this when we implement the modules. It's recommended to use modules when you're relatively sure that the context boundaries are right. Therefor, you should start with a single module and use strategic Domain-Driven Design iteratively to explore the problem space and identify context boundaries. As your domain knowledge grows, the code base will grow, too. Context boundaries become clearer and you can use that to your advantage. Autonomous modules help you to keep control. They avoid accidental complexity by ensuring context boundaries and therefor a clear focus on a specific problem.Systems that neither use modules nor microservices often end up in numerous layers which are hard to understand and debug. Software layers also have the negative effect that all parts of the system are coupled with each other. Again, missing boundaries are the reason. At the beginning of a new project you don't recognize the problem but one or two years later you'll end up with an unmaintainable mess.To be able to refactor parts of the system at any given point in time - be it after 3 months or 3 years - it is essential to not fear the deletion of code. @gregoryyoung addresses the topic in a great talk: The art of destroying software. Autonomous modules and microservices both give you the freedom to delete code and start from scratch whenever new requirements force you to reshape the model.That's enough technical detail for now. On the next page you'll get a first overview of the domain."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/intro\/the_domain.html#1-4","title":"The Domain","content":"As stated in the introduction, the Fee Office is based on an \"es-emergency-call\" and therefor represents the prototype implementation of a real domain.What follows is an introduction of the problem space given by @enumag: The business is about providing accountancy services to the owners of large buildings or organizations that take care of the building when each apartment is owned by a different person. First let's say the database is empty so we need to add some data. The first thing to add is a building, it's entrances (each entrance has a different address) and the apartments in the building. Then we need to add the contracts - who owns and who lives in each apartment. These people need to pay some fees every months which is where our company comes in - to help determine what fees they should pay and observe if they are indeed paying them. When adding a new building, most of the data about apartments, contracts and people are loaded from an external database or an import file. Next we need to tell the system what fees should the people pay and how to calculate the exact amounts (since they can differ each month but can be calculated). This is represented by the FeeRecipe entity. Each contract usually has around 5-10 FeeRecipes. As you can see in the diagram there is a FinancialAccount entity between Contract and FeeRecipe. Most often each contract only has one FinancialAccount but in some edge cases there can be more. This is required because the Fees on different FinancialAccounts are treated a bit differently in some cases based on the attributes of the FinancialAccount but the details are unimportant.  In the draw.io representation I went for something close to an UML diagram, but focusing just on the relations. The diagram represents what a relational schema would look like - in fact this is pretty much what our PostgreSQL projection looks like. I did cut a few less important things here and there such as that each ContactCard hold some addresses, phones, emails etc - these details are not important for this issue in my opinion. At the end of each month an automated process takes each (still active) FeeRecipe and generates a new Fee for it for that month. The calculation requires the formula from the FeeRecipe and the current ApartmentAttributeValues on the related Appartment. ApartmentAttributes are properties of the apartment such as bodycount (how many people live in the apartment at the time) which can change every now and then. Each change is represented by a new ApartmentAttributeValue. Next looking from the other side of the diagram there is an AccountingOrganization. In most cases an AccountingOrganizations is 1:1 with Building but there are exceptions with one AccountingOrganization handling multiple buildings and also exceptions with one building being split to multiple AccountingOrganizations. Therefore we made them completely independent. FinancialAccountGroup is actually a brand new entity we came up with just this morning after discovering some serious problems in our PaymentAllocations process. Basically it's a group of FinancialAccounts that holds some options how should the Payments be allocated to Fees. FinancialAccountGroup is actually the scope for the PaymentAllocations process - take all not-fully-allocated Payments and FeeItems related to the FinancialAccountGroup and do the process described in the previous issue. PaymentPreference holds a reference number that we can use to match a given payment from the import to a specific person and FinancialAccountGroup. The process of matching imported payments to people converts UnassignedPayment to Payment. Finally the ContactCard represents a Person or Company and can be referenced pretty much anywhere in the system. It can be an employee of our company, an owner of an apartment, an organization managing a building, a contractor our company cooperates with etc. That's a lot of information, isn't it? The team has some struggle with identifying the \"right\" bounded contexts and aggregates. @enumag summarizes it like this: Our struggle mostly comes down to the uncertainty of \"how big should an aggregate be\" - where the answer is of course \"it depends\" but I'm unsure \"what exactly it depends on\". Should each of the entities in the diagram be an aggregate? If not then how far should one aggregate go? Is there some limit to how much data should an aggregate hold or how many different methods, related commands and events it should have? For now most of the things on the diagram are actually aggregates (with a few more aggregates planned to oversee the automated processes) with the structure being split to around 5 bounded contexts. Is that too many? Another problem is that some parts of the structure are pretty much pure CRUD - Building, Entrance, Apartment, ApartmentAttributeValue, Contract, FinancialAccount, FeeRecipe, ContactCard - all of that is pretty pure CRUD, albait some parts are automated with imports. The reason why we chose to use DDD are the processes around generating fees, finding out which payment was payed by who and which payment pays which fees (the last process is explained a bit more in #6). Also having the entire event sourced history will be beneficial in some of the processes and also other parts that are not yet represented on the diagram (such as calculating penalties for late payments). This puts us in a not very good position where we need to deal with CRUD in ES\/CQRS while knowing that ES\/CQRS is not really the best thing for CRUD. Two common problems for teams using DDD, CQRS and Event Sourcing for the first time. Let's see if we can help the team with some guidance and a prototype of a modularized application with each module representing a bounded context of the domain.On the next page we'll sort the information given above and take a first look at the bounded contexts."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1","title":"Interviewing Domain Experts","content":"On the previous page we got some insights of the Fee Office domain. @enumag provided the information from a developer point of view. However, he is our domain expert at the moment and that's a common scenario in the real world, too. Often developers working for the company for a long time are the best domain experts. They've built the legacy systems and dealt with the business logic for many years. They know all the edge cases.It doesn't mean you should only talk to developers. Their view of the business is often driven by a technical mindset. Find a way to get access to real domain experts as often as possible. Usually they are very busy, but try it anyway.And like a true domain expert @enumag provided a lot of information in one go. When talking to domain experts you need to be prepared. One good question can cause a long discussion. You can get access to very important knowledge but the domain experts will use their language and you probably won't understand everything right away.@cyriux gave a great talk about the topic at DDD Europe 2016: Interviewing Domain Experts: heuristics from the trenchesGiven the advices of the talk we can take @enumag's domain introduction, group the information and highlight key phrases that sound important."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-1","title":"[Supporting] RealtyRegistration","content":"Building- &gt; Entrance -&gt; Appartement -&gt; ContractThe business is about providing accountancy services to the owners of large buildings or organizations that take care of the building when each apartment is owned by a different person.The first thing to add is a building, it's entrances (each entrance has a different address) and the apartments in the building.ApartmentAttributes are properties of the apartment such as bodycount (how many people live in the apartment at the time) which can change every now and then. !!!Attention!!! -&gt; Each change is represented by a new ApartmentAttributeValue.Then we need to add the contracts - who owns and who lives in each apartment."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-1-1","title":"From Import","content":"When adding a new building, most of the data about apartments, contracts and people are loaded from an external database or an import file."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-2","title":"[Supporting] FeeRecipe","content":"Next we need to tell the system what fees should the people pay and how to calculate the exact amounts (since they can differ each month but can be calculated). This is represented by the FeeRecipe entity.Each contract usually has around 5-10 FeeRecipes.there is a FinancialAccount entity between Contract and FeeRecipe. Most often each contract only has one FinancialAccount but in some edge cases there can be more. This is required because the Fees on different FinancialAccounts are treated a bit differently in some cases based on the attributes of the FinancialAccount but the details are unimportant."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-3","title":"[Supporting] Accounting","content":"Next looking from the other side of the diagram there is an AccountingOrganization. In most cases an AccountingOrganizations is 1:1 with Building but there are exceptions with one AccountingOrganization handling multiple buildings and also exceptions with one building being split to multiple AccountingOrganizations. Therefore we made them completely independent. +1"},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-4","title":"[Supporting] ContactAdministration","content":"Finally the ContactCard represents a Person or Company and can be referenced pretty much anywhere in the system. It can be an employee of our company, an owner of an apartment, an organization managing a building, a contractor our company cooperates with etc."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-5","title":"[Supporting] PaymentCollecting?","content":"Maybe this context and FeeCalculating belong to the same core context?"},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-6","title":"[Core] FeeCalculating","content":"These people need to pay some fees every months which is where our company comes in - to help determine what fees they should pay and observe if they are indeed paying them.At the end of each month an automated process takes each (still active) FeeRecipe and generates a new Fee for it for that month. The calculation requires the formula from the FeeRecipe and the current ApartmentAttributeValues on the related Appartment."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-6-1","title":"Needs Clarification","content":"FinancialAccountGroup is actually a brand new entity we came up with just this morning after discovering some serious problems in our PaymentAllocations process. Basically it's a group of FinancialAccounts that holds some options how should the Payments be allocated to Fees. FinancialAccountGroup is actually the scope for the PaymentAllocations process - take all not-fully-allocated Payments and FeeItems related to the FinancialAccountGroup and do the process described in the previous issue."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-1-7","title":"Payment Import","content":"PaymentPreference holds a reference number that we can use to match a given payment from the import to a specific person and FinancialAccountGroup. The process of matching imported payments to people converts UnassignedPayment to Payment."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/interview.html#2-1-2","title":"Explanation of the notes","content":"I've grouped the information by context. Please keep in mind that this grouping is only based on my very first understanding of the domain. It's not the final result. In the demo you find a slightly different set of contexts. Anyway, it's a starting point to gain knowledge and connect the dots. I've highlighted phrases and words that seem important. They are part of the Ubiquitous Language and a good basis for further questions. I also tried to categorize contexts into supporting and core. The core domain is the context of the system that makes it unique and generates money. The core should get the most attention. Supporting contexts - well - support the core. We'll see that in action when implementing prototypes of each context. I also used question and exclamation marks to highlight hot spots (topics I want to clarify).On the next page we'll create a first context map."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2","title":"Context Mapping","content":"Instead of giving an introduction about context mapping myself I think it's better to link to existing sources. That said, please read the Strategic Domain Driven Design with Context Mapping article on InfoQ.We need to gather information about the company's structure as well as the system landscape. Therefor I've asked a few questions and @enumag answered them:Where do you get the data from? When possible the data are imported from a file (let's say XML) or from an external database. When not possible they are added in manually by our employees. Later modifications are all done manually as far as I know. Who is responsible for the data? Our emloyees, although I'm not sure if that's what you're asking. How often does the data change? Not too often. Usually just when an apartment is sold. Other than that people can report changes in their contacts, addresses etc. What data changes influence the fee generation process and how? Any change on FeeRecipe and any change on ApartmentAttributeValue. Possibly something on Apartment but that should be all.  Change on FeeRecipe usually means change to the formula to calculate the fee. Change on ApartmentAttributeValue means a change to the variables used in that formula. We're using Symfony\/ExpressionLanguage to calculate the actual fee amounts from this data. Which departments of your company work with the system and what specific part do they use or are responsible for?Is only one developer team working on the software or do you have multiple teams? If so, who works on which part?Do you integrate with third-party services or provide an API for foreign systems? The company is not too large so 1 dev team, couple of employees who work with the system, each taking care of a few buildings. We will surely integrate with 3rd party APIs to import some data and the plan is to also provide our own API in the future - that's why the backend is GraphQL application with frontend being a JS client running in the browser. "},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-1","title":"Rinse And Repeat","content":"The context map we are drawing is not a final thing. Whenever new concepts arise for example integration of external systems, growing company, new software modules .... You have to revisit the context map and check if it needs to be aligned. Same is true for the implementation itself. Hence, we start with a modularized monolith and only turn modules into independent (micro)services if we are:a) relatively sure the context boundary is right and b) need to scale that module"},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-2","title":"First Map","content":"For now a simple context map is all we need because only one team is working on the system and the company structure is also relatively flat with a few people working with the system."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-1","title":"RealtyRegistration","content":"Adding a realty and all the details about the apartments and people is the first thing you need to do in the system. It can be done manually or by some import. It made sense to separate this from the rest of the logic in the system.With that said the border between RealtyRegistration and FeeCalculating is really unclear for now."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-2","title":"FeeCalculating","content":"This context is supposed take care of the second part where we need to generate the fees every month.The main struggle here is that to generate those fees we need some data from RealtyRegistration so we're unsure if those data should be in RealtyRegistration or in FeeCalculating or somehow in both. I'm mainly talking about the ApatrmentAttributeValues (such as body count and area). This is the weakest point in the current structure."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-3","title":"PaymentCollecting","content":"We need to collect payments from multiple sources (files, external APIs, manual registration) so again we wanted to separate this from the rest.But then, as you know, we need to allocate the payments to generated fees so it's unclear what's correct here."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-4","title":"Accounting","content":"At the moment this BC only contains AccountingOrganization. It feels empty to be honest but putting this aggregate inside PaymentCollecting doesn't feel right either because it will also be needed for other things than payments. Again this is one of the weak points in the current structure and most likely it's wrong."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-5","title":"ContactAdministration","content":"This one I'm quite satisfied with for now. It separates the contact information from everything else since each contact can be used for several different purposes.One thing I'm note quite sure about here is how to handle deletion because you should not be able to delete a contact that is used somewhere else. But this BC doesn't know if a contact is used and where. Should it be aware of it or not?"},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-3-6","title":"FeeRecipe","content":"FeeRecipe is not a bounded context. It's an aggregate inside FeeCalculating bounded context."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-1","title":"RealtyRegistration - FeeCalculating","content":"FeeCalculating needs some data from RealtyRegistration to perform its tasks."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-2","title":"FeeCalculating - PaymentCollecting","content":"Fees and Payments need to be allocated to each other."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-3","title":"PaymentCollecting - Accounting","content":"Each entity in PaymentCollecting belongs to one AccountingOrganization. I've explained the reason why AccountingOrganization is separate above."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-4","title":"ContactAdministration - RealtyRegistration","content":"Each building has several employees of our company assigned to it. Those employees are taking care of whatever is needed to be done regarding that building."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-5","title":"ContactAdministration - PaymentCollecting","content":"Each payment needs to be assigned to the person who paid it. Or more exactly to a FinancialAccountGroup that belongs to that person. Each FinancialAccountGroup holds an id of a ContactCard."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/context_mapping.html#2-2-4-6","title":"ContactAdministration - Accounting","content":"AccountingOrganization is a corporate body and as such it holds id of a ContactCard that holds the information about it.With a first context map in place we can move on and use event storming to dive deeper into the domain, verify our context boundaries and get an idea of the model. Head over to the next page for more."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/eveent_storming.html#2-3","title":"Event Storming","content":"We already learned a lot about the Fee Office. What's missing is a better understanding of the processes.What happens when?What are the preconditions for certain actions?How does the happy path look like?And do we need to take care of some unhappy paths as well?Many questions, right? Fortunately, @ziobrando has developed a flexible workshop format called EventStorming. Follow the link for a comprehensive list of resources."},{"id":"https:\/\/proophsoftware.github.io\/fee-office\/ddd\/eveent_storming.html#2-3-1","title":"Basics","content":"EventStorming is really easy to learn and all sessions I did myself had amazing results. I can only recommend to read about it, watch a few presentations, buy the book Introducing EventStorming by Alberto Brandolini (@ziobrando) and actually try it with your team and domain experts.For the Fee Office we started simple again. EventStorming works best with all people in one room and unlimited modeling space. However, we tried remote EventStorming using a realtimeboard. Obviously, you can't achieve the same quality results in a remote session, especially when communication happens asynchronous via chat (or github issue in our case).But it's still a great way for collaboration and for sharing ideas. Here are the basic colors for different types of sticky notes:With this basic set of colors we just started modeling. The first sticky note is the most difficult one. Like the name suggests EventStorming puts the focus on events or more precise on domain events. I've asked @enumag to put a few high level events on the board. Here is the result:That's a really good way to start. Now you can ask questions related to each of those events and zoom into the processes centered around them. I asked the following two questions: Who adds those fee recipes? What happens if a fee recipe has a mistake? And the board got a massive update: There are some nuances about what to do with already generated incorrect fees. I tried to added some notes to the board regarding that. Hopefully that should answer your questions. I tried to use the color scheme from your comment above (+ I added light green for conditions). There is one new thing for you here - \"accounted for fees\". Usually in april we need to wrap up the previous year. When that happens some documents are created and most actions are no longer available with the payments and fees for that year (and they become \"accounted for\"). We didn't delve too deep into that just yet - we have other things to solve before that. There is one thing though about the notes I just added to the board. While these actions are needed to fix incorrect fee recipes, they are not specific to that process. It's just some tools the building referent (employee of our company who works with the system) needs to have at their disposal. For example unallocating and reallocating payments is also done when we discover some old payment that was not added into the system because of a mistake. So while I added the notes close to fee recipe addition for now, it doesn't really feel correct to have it that way. How should things like that be represented on the board? Do you recognize what happened? Two simple questions brought up completely new knowledge: accounted for fees as well as a new important term: building referent that we can add to the Ubiquitous Language and use in further discussions. That's the power of EventStorming. You gain a lot of knowledge about the domain in a very short period of time.Given the new information I asked the next questions: I guess unallocating and reallocating payments is also done when an ApartementAttributeValue is wrong?  After checking with my teammates I found out it works differently. It's not necessary to change the old fees in this case because the difference will be calculated with when we wrap up the year the next april. Basically it doesn't matter if the people paid something wrong, it will all be fixed in this yearly audit but we don't need to actually change the old fees in most cases.  Is there some kind of \"monthly deadline\" for building referents (note how I use the newly learned term here) until ApartmentAttributes changes should be made, so that the automated fee generation process can work with a fixed set of information?  No because there is no way to tell if we received all the changes or if there even were any changes. I'll double check with my colleagues though. And of course we added new sticky notes to the board:You might notice that two notes are a copy of already existing notes. The \"developer DRY thinking\" isn't really useful for EventStorming. Use the same notes as often as needed. Move them around, rearrange and try different grouping. It is much cheaper to move stickies around and develop an idea of the system on the wall than starting to write code just to realize two weeks later that your assumptions were wrong!We got a lot of domain knowledge. Now it's time for the first development iteration. We'll start with a prototype. Head over to the next page for details."}]